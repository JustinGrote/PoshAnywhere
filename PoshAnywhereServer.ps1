#Exposes the Powershell Remoting Protocol via a TCP Port
using namespace System.Management.Automation.Runspaces
using namespace System.Net.Sockets
using namespace System.Threading.Tasks
using namespace System.IO.Pipes
using namespace System.IO

[CmdletBinding(DefaultParameterSetName = 'Server')]
param (
  [Parameter(Position = 0, ParameterSetName = 'Client')][String]$ComputerName = 'localhost',
  [Parameter(ParameterSetName = 'Client')][String]$PipeName = $("PSHost.$ComputerName.$(New-Guid)"),
  [Int]$Port = 7073,
  [Parameter(ParameterSetName = 'Server')][ipaddress]$ListenAddress = '127.0.0.1',
  [Parameter(ParameterSetName = 'Server')][Switch]$AllowRemoteConnections,
  [Parameter(ParameterSetName = 'Server')][Switch]$NoSSHRelay,
  [Parameter(ParameterSetName = 'Server')][String]$SSHRelayHost = 'pwsh.link',
  [Parameter(ParameterSetName = 'Server')][Int]$SSHRelayPort = 2222
)

if ($AllowRemoteConnections) { $ListenAddress = '0.0.0.0' }

function Get-PSRemotingNamedPipe() {
  <#
  .SYNOPSIS
  Gets the PSRemoting autogenerated named pipe of the specified process
  .NOTES
  Reimplementation of internal powershell method NamedPipeUtils.CreateProcessPipeName
  #>
  param(
    [int]$ID = $PID,
    [switch]$PipeNameOnly
  )
  $process = Get-Process -Id $ID -ErrorAction Stop
  $processStartTime = $process.starttime.tofiletime()

  $processStartId = if ($PSEdition -eq 'Desktop' -or $isWindows) {
    $processStartTime
  } else {
    $processStartTime.ToString('X8').Substring(1, 8)
  }

  $pipeName = (@(
      'PSHost'
      $processStartID
      $process.Id
      'DefaultAppDomain'
      $process.ProcessName
    ) -join '.').ToString([cultureinfo]::InvariantCulture)
  if ($PipeNameOnly) { return $pipeName }

  if (-not ($PSEdition -eq 'Desktop' -or $isWindows)) {
    return $pipeName = "/tmp/CoreFxPipe_$pipeName"
  } else {
    return $pipeName = "\\.\pipe\$pipeName"
  }
}

function Connect-PSRemotingNamedPipe([String]$Name = (Get-PSRemotingNamedPipe -PipeNameOnly), [String]$ComputerName = '.') {
  #Connect the debug pipe
  $pipeclient = [NamedPipeClientStream]::new(
    $ComputerName, #string serverName
    $Name, #string pipeName
    [PipeDirection]::InOut, #PipeDirection direction
    [PipeOptions]::Asynchronous #PipeOptions options
  )
  Write-Host -NoNewline -Fore Cyan "Connecting to Powershell Named Pipe $Name..."
  $pipeclient.Connect()
  Write-Host -Fore Green 'OK!'
  return $pipeClient
}

function Start-PSRemotingTCPListener ([Int]$Port = 7073, [ipaddress]$ListenAddress = '127.0.0.1') {
  #Connect the tcp listener. 7073 = ps in hex :)
  $tcpListener = [TcpListener]::new($ListenAddress, $port)
  $tcpListener.Start()
  Write-Host -NoNewline -Fore Cyan "Waiting for connection to ${listenAddress}:$port..."
  $tcpClient = $tcpListener.AcceptTcpClient()
  Write-Host -Fore Green 'OK!'
  return $tcpClient
}

function Join-Stream {
  param (
    #Provide an array of two streams to join together
    [ValidateCount(2, 2)][Stream[]]$Stream,
    #Wait for one of the streams to complete or disconnect. The script will return the first stream to disconnect
    [Switch]$Wait
  )
  $copyStreamTasks = @(
    $Stream[0].CopyToAsync($Stream[1])
    $Stream[1].CopyToAsync($Stream[0])
  )
  if ($Wait) {
    $completedTaskIndex = [Task]::WaitAny($copyStreamTasks)
    return $copyStreamTasks[$completedTaskIndex]
  } else {
    $copyStreamTasks
  }
}

#region main
try {
  $pipeClient = Connect-PSRemotingNamedPipe
  $tcpClient = Start-PSRemotingTCPListener
  $firstClosedStream = Join-Stream -Wait $pipeClient, $tcpClient.GetStream()
  if (-not $firstClosedStream.IsCompletedSuccessfully) {
    throw $firstClosedStream.Exception
  }
} catch { Write-Error $PSItem } finally {
  $pipeClient.Close()
  $pipeClient.Dispose()
  $tcpClient.Close()
  $tcpClient.Dispose()
  if ($tcpListener) { $tcpListener.Stop() }
}
#endregion main
