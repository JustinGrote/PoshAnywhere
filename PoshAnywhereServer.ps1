#Exposes the Powershell Remoting Protocol via a TCP Port
using namespace System.Management.Automation.Runspaces
using namespace System.Net.Sockets
using namespace System.Net.WebSockets
using namespace System.Collections.Generic
using namespace System.Threading
using namespace System.Threading.Tasks
using namespace System.IO.Pipes
using namespace System.IO
using namespace System.Net
using namespace System.Text

param (
  #Use a raw tcp listener instead of a websocket
  [Switch]$TCP,
  [Parameter(ParameterSetName = 'Server')][Switch]$AllowRemoteConnections
)

if ($AllowRemoteConnections) { $ListenAddress = '0.0.0.0' }

function Get-PSRemotingNamedPipe() {
  <#
  .SYNOPSIS
  Gets the PSRemoting autogenerated named pipe of the specified process
  .NOTES
  Reimplementation of internal powershell method NamedPipeUtils.CreateProcessPipeName
  #>
  param(
    [int]$ID = $PID,
    [switch]$PipeNameOnly
  )
  $process = Get-Process -Id $ID -ErrorAction Stop
  $processStartTime = $process.starttime.tofiletime()

  $processStartId = if ($PSEdition -eq 'Desktop' -or $isWindows) {
    $processStartTime
  } else {
    $processStartTime.ToString('X8').Substring(1, 8)
  }

  $pipeName = (@(
      'PSHost'
      $processStartID
      $process.Id
      'DefaultAppDomain'
      $process.ProcessName
    ) -join '.').ToString([cultureinfo]::InvariantCulture)
  if ($PipeNameOnly) { return $pipeName }

  if (-not ($PSEdition -eq 'Desktop' -or $isWindows)) {
    return $pipeName = "/tmp/CoreFxPipe_$pipeName"
  } else {
    return $pipeName = "\\.\pipe\$pipeName"
  }
}

function Connect-PSRemotingNamedPipe([String]$Name = (Get-PSRemotingNamedPipe -PipeNameOnly), [String]$ComputerName = '.') {
  #Connect the debug pipe
  $pipeclient = [NamedPipeClientStream]::new(
    $ComputerName, #string serverName
    $Name, #string pipeName
    [PipeDirection]::InOut, #PipeDirection direction
    [PipeOptions]::Asynchronous #PipeOptions options
  )
  Write-Host -NoNewline -Fore Cyan "Connecting to Powershell Named Pipe $Name..."
  $pipeclient.Connect()
  Write-Host -Fore Green 'OK!'
  return $pipeClient
}

function Start-PSRemotingTCPListener ([Int]$Port = 7073, [ipaddress]$ListenAddress = '127.0.0.1') {
  #Connect the tcp listener. 7073 = ps in hex :)
  $tcpListener = [TcpListener]::new($ListenAddress, $port)
  $tcpListener.Start()
  Write-Host -NoNewline -Fore Cyan "Waiting for connection to ${listenAddress}:$port..."
  $tcpClient = $tcpListener.AcceptTcpClient()
  Write-Host -Fore Green 'OK!'
  return $tcpClient
}

function Join-Stream {
  param (
    #Provide an array of two streams to join together
    [ValidateCount(2, 2)][Stream[]]$Stream,
    #Wait for one of the streams to complete or disconnect. The script will return the first stream to disconnect
    [Switch]$Wait
  )
  $copyStreamTasks = @(
    $Stream[0].CopyToAsync($Stream[1])
    $Stream[1].CopyToAsync($Stream[0])
  )
  if ($Wait) {
    $completedTaskIndex = [Task]::WaitAny($copyStreamTasks)
    return $copyStreamTasks[$completedTaskIndex]
  } else {
    $copyStreamTasks
  }
}

#Region WebSocketServer

# Binds a websocket to a stream. You should provide a connected, async inout pipe stream with autoflush enabled.
function Start-WebSocketStreamServer ([ValidateNotNullOrEmpty()][int]$Port = 7073, [Stream]$PipeStream) {
  try {
    $prefix = "http://localhost:$Port/psrp/"
    $server = [HttpListener]::new()
    $server.Prefixes.Add($Prefix)
    $server.Start()
    Write-Host "Websocket Server listening on $prefix"

    #This is the outer loop that accepts connections. We may not need a loop here but it may help with reconnections.
    while ($true) {
      $contextTask = $server.GetContextAsync()

      #This loop allows Ctrl-C to keep working
      while ($contextTask.Wait(500) -ne $true) {}
      $context = $contextTask.GetAwaiter().GetResult()

      if (-not $context.Request.IsWebSocketRequest) {
        Write-Host 'WEBSOCKET: non-websocket request received. Disconnecting'
        $context.Response.StatusCode = 400
        $context.Response.Close()
        continue
      }

      Write-Host "WEBSOCKET: connection from $($context.Request.RemoteEndPoint)"
      try {
        # Powershell will cast null to an empty string, in this case we need to force an actual null
        $websocketContext = $context.AcceptWebSocketAsync([nullstring]::Value).GetAwaiter().GetResult()
        $websocket = $websocketContext.WebSocket
        Join-WebsocketToStream -Websocket $websocket -Stream $PipeStream
      } catch {
        Write-Host "WEBSOCKET: Error accepting websocket request: $($_.Exception.Message)"
        $context.Response.StatusCode = 500
        $context.Response.Close()
        continue
      } finally {
        $websocket.Dispose()
      }
    }
  } catch {
    throw
  } finally {
    if ($server) {
      Write-Host 'WEBSOCKET: Stopping Server...'
      $server.Stop()
    }
  }
}

function Join-WebsocketToStream ([WebSocket]$Websocket, [Stream]$Stream) {
  <#
  .SYNOPSIS
  Joins a websocket to a stream and handles messaging between the two. You should provide a connected, async inout pipe stream
  #>

  $fromPipeTask = $null
  $fromWebSocketTask = $null
  $pendingWriteTask = $null
  [List[object]]$activeTasks = @()

  try {
    $pipeReader = [StreamReader]::new($Stream)
    [ArraySegment[byte]]$receiveBuffer = [ArraySegment[byte]]::new([byte[]]::new(8192))

    #This outer loop uses Tasks to keep from blocking on either the websocket or the pipe, and acts on them as messages come in. This also ensures the websocket is never concurrently written to/read from, which is not allowed.
    while ($Websocket.State -eq [WebSocketState]::Open) {
      if (-not $fromPipeTask) {
        $fromPipeTask = $pipeReader.ReadLineAsync()
        $activeTasks.Add($fromPipeTask)
      }
      if (-not $fromWebSocketTask) {
        $fromWebSocketTask = $websocket.ReceiveAsync($receiveBuffer, [CancellationToken]::None)
        $activeTasks.Add($fromWebSocketTask)
      }

      #This is the core of the loop, we wait until either we recieve data from the named pipe or the websocket. If the timeout is reached, check that the connection is still open. We use 500ms to allow for Ctrl-C to work in a reasonable timeframe.
      do {
        [int]$TIMEOUT_REACHED = -1
        [int]$completedTaskIndex = [Task]::WaitAny($activeTasks, 500)

        if (
          $completedTaskIndex -eq $TIMEOUT_REACHED -and
          $websocket.State -ne [WebSocketState]::Open
        ) {
          Write-Host "WEBSOCKET: Websocket is no longer open. Current Status: $websocket.State"
          break
        }
      } until ($completedTaskIndex -ne $TIMEOUT_REACHED)

      $completedTask = $activeTasks[$completedTaskIndex]
      $activeTasks.RemoveAt($completedTaskIndex)

      #If the websocket task completed, it means we received a message from the websocket and we need to send the data to the named pipe
      if ($completedTask -eq $fromWebSocketTask) {
        #Buffers can be tricky, so we instead capture everything into a memorystream and then extract the string out of that.
        Write-Host 'WEBSOCKET: Begin Message Receive From Client'
        $result = $fromWebSocketTask.GetAwaiter().GetResult()

        #We only want to load the data that was received, whatever is after that is unreliable
        $receiveStream = [MemoryStream]::new($receiveBuffer[0..$result.Count])

        while (-not $result.EndOfMessage) {
          # We don't need to reset $receiveBuffer here because it will be overwritten by the next ReceiveAsync call
          $result = $websocket.ReceiveAsync($receiveBuffer, [CancellationToken]::None).GetAwaiter().GetResult()
          $receiveStream.Write($receiveBuffer, 0, $result.Count)
          if ($result.MessageType -eq [WebSocketMessageType]::Close) {
            Write-Host 'WEBSOCKET: Received Close Request from Client. Responding with NormalClosure'
            $websocket.CloseAsync('NormalClosure', '', [CancellationToken]::None).GetAwaiter().GetResult()
            break
          }
        }

        #Rewind the stream and output the captured bytes to the named pipe
        Write-Host "WEBSOCKET: Received Message of length $($receiveStream.Length) from Client. Sending to Named Pipe"
        $receiveStream.Position = 0
        $receiveStream.CopyTo($Stream)
        $Stream.Write(([encoding]::UTF8.GetBytes([Environment]::NewLine)))

        #Reset the websocket task to await a new message
        $fromWebSocketTask = $null
      }

      #If the pipe task completed, it means a message came from the PSRP pipe and we need to send the data to the websocket
      if ($completedTask -eq $fromPipeTask) {
        #Fetch a PSXML message from the named pipe. While we only care about the bytes, we use streamreader Readline() as a simple way to look for newlines as message delimiters, and that returns a string which we need to deconstruct back down into bytes to pass along. A faster solution would be to look for the newline ourselves within the byte array, but that's not enough of a perf gain to justify the complexity.
        $pipeMessage = $fromPipeTask.GetAwaiter().GetResult()
        Write-Host "PIPE RECEIVED: $pipeMessage"

        #If an existing pendingWriteTask exists, wait for it to finish. We are not allowed to have simultaneous writes to a websocket.
        if ($pendingWriteTask) {
          $pendingWriteTask.GetAwaiter().GetResult() | Out-Null
          $pendingWriteTask = $null
        }

        $messageBytes = [Encoding]::UTF8.GetBytes($pipeMessage)
        $payload = [ArraySegment[byte]]::new($messageBytes)
        $pendingWriteTask = $websocket.SendAsync($payload, [WebSocketMessageType]::Text, $true, [CancellationToken]::None)
        Write-Host 'Websocket Sent'
      }
    }
  } catch {
    Write-Host "WEBSOCKET: Error in Websocket Message Handling: $PSItem"
    throw
  } finally {
    Write-Host 'WEBSOCKET: Closing websocket'
    $stream.Dispose()
  }
}


#region main
try {
  $pipeClient = Connect-PSRemotingNamedPipe

  if ($TCP) {
    $tcpClient = Start-PSRemotingTCPListener
    $firstClosedStream = Join-Stream -Wait $pipeClient, $tcpClient.GetStream()
    if (-not $firstClosedStream.IsCompletedSuccessfully) {
      throw $firstClosedStream.Exception
    }
    return
  }

  #Default Websocket Implementation
  Start-WebSocketStreamServer -PipeStream $pipeClient

} catch { Write-Error $PSItem } finally {
  $pipeClient.Close()
  $pipeClient.Dispose()
  if ($TCP) {
    $tcpClient.Close()
    $tcpClient.Dispose()
    if ($tcpListener) { $tcpListener.Stop() }
  }
}
#endregion main